{
  "id": "md2f6u6bv779qgltnz",
  "topic": "System Design Interview: Design Live Comments w/ a Ex-Meta Staff Engineer",
  "content": "### Filtered Resources\n\n- [Guided Practice](https://www.hellointerview.com/practice)\n- [Detailed Write Up of the Problem](https://www.hellointerview.com/learn/system-design/answer-keys/fb-live-comments)\n- [System Design In a Hurry](https://www.hellointerview.com/learn/system-design/in-a-hurry/introduction)\n- [Excalidraw for Diagrams](https://link.excalidraw.com/l/56zGeHiLyKZ/6xaHKVKAEq7)\n\n### Video Overview\n\nIn this video, Evan, a former Meta Staff Engineer, explains the system design interview for creating Facebook Live Comments. This commonly asked question in FAANG interviews requires outlining requirements, understanding the API and core entities, high-level system design (HLD), and in-depth exploration into optimizing scalability and low latency through efficient architectural strategies.\n\n### Detailed Technical Content\n\n1. **The Approach**\n   - **Requirements Analysis**:\n     - **Functional Requirements**:\n       - Users must be able to post comments swiftly.\n       - Comments must be visible to all viewers in near real-time.\n       - New users joining a live must be able to see past comments.\n     - **Non-functional Requirements**:\n       - High scalability: Support millions of concurrent videos.\n       - Availability must be prioritized over consistency (CAP Theorem).\n       - Aim for low latency (target approximately 200ms as perceived real-time by humans).\n\n2. **API & Core Entities**:\n   - **Core Entities**:\n     - **Comments**: Includes ID, video ID, author ID, contents, and timestamp.\n     - **Live Videos**: Artists and relationship mapping with comments.\n     - **Users**: Participants posting and viewing comments.\n   - **API Design**:\n     - **Post Comment API**: Endpoint to allow users to post comments. Designed as a RESTful POST method.\n     - **Get Comments API**: Supports retrieving comments with cursor-based pagination ensuring efficient loading of comments as users scroll.\n\n3. **High-Level Design (HLD)**:\n   - **System Architecture**:\n     - **Client-Server Architecture**: High-level interaction involves clients, an API Gateway, Comment Service, and a database.\n     - **CRUD Operations**: Comment service supports creating and reading comments.\n   - **Database Design**:\n     - Considerations for SQL vs. NoSQL databases due to efficiency in read/write operations, eventual consistency, and indexing requirements.\n     - Optimal use of indices on video ID and sorting by creation time for fast retrieval.\n\n4. **Deep Dives**:\n   - **Low Latency & Scalability**:\n     - **Ensuring Low Latency**:\n       - From basic polling (inefficient) to using WebSockets or SSE (Server-Sent Events) for persistent connections.\n       - **WebSockets** bring inherent complexity due to bidirectional nature and reliance on non-HTTP protocols.\n       - **SSE** is preferred due to unidirectional data flow, fitting naturally to the problem's requirements and utilizing HTTP/HTTPS.\n   - **Scalability Strategies**:\n     - Horizontal scaling using real-time comment services dedicated to handling SSE connections which can be scalable and manageable.\n     - **Central Dispatcher/Coordination Service** vs. **Pub/Sub Model**:\n       - Zookeeper helps maintain server mappings to dictate routing for new comments.\n       - Pub/sub systems like Reddis/Kafka suitable for broadcasting changes reducing centralized decision overhead and improving fault tolerance.\n     - Optimizing connection loads using partitioned Pub/sub topics based on video IDs to minimize unnecessary processing load.\n\n5. **Handling Failure Scenarios**:\n   - **Fault Tolerance**:\n     - Discuss strategies for handling server failures, ensuring redundancy, and graceful degradation.\n     - Re-connection strategies for lost SSE connections ensuring a robust user experience.\n\n6. **Conclusion**:\n   - Finalizing a design that minimizes latency, is scalable with increasing loads, ensures data consistency when it matters least, and provides thorough analysis and reasoning supporting each architectural choice.\n\n### Key Takeaways\n\n- A robust system for Facebook Live Comments balances functional and non-functional requirements, emphasizing high scalability and low-latency delivery using advanced architectural strategies.\n- While WebSockets and SSE provide foundational real-time communication models, the specific choice should depend on use-case requirementsâ€”unidirectional or bidirectional data flow.\n- Deep architectural consideration, including efficient data store selections (Cassandra, PostgreSQL), distributed system pattern implementations, and efficient API design, is crucial for ensuring a performant system.\n- The system's scalability is best managed with a distributed Pub/sub strategy, considering capped consistent or eventual information retrieval approaches.",
  "createdAt": "2025-07-14T01:23:46.115Z",
  "updatedAt": "2025-07-14T03:27:08.062Z",
  "keywords": [
    "postgresql",
    "kafka",
    "websockets",
    "system-design",
    "chat-messaging",
    "streaming-media",
    "social-media",
    "web-crawler",
    "code-editor",
    "progress-components",
    "interview-prep"
  ]
}