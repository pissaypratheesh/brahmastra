{
  "id": "md1zvp868zgksmv0ris",
  "topic": "Netflix Frontend System Design | Front-end System Design | üí™ Chakde System Design Ep. 6",
  "content": "## üìã Table of Contents\n- [1. Filtered Resources](#filtered-resources)\n- [2. Video Overview](#video-overview)\n- [3. Detailed Technical Content](#detailed-technical-content)\n  - [3.1 Functional and Non-Functional Requirements](#functional-and-non-functional-requirements)\n  - [3.2 Scoping](#scoping)\n  - [3.3 Tech Stack of Netflix](#tech-stack-of-netflix)\n  - [3.4 Component Design](#component-design)\n  - [3.5 Implementation Details](#implementation-details)\n- [4. Key Takeaways](#key-takeaways)\n\n---\n\n# Filtered Resources\n\n- [ReactJS](https://reactjs.org/)\n- [TypeScript](https://www.typescriptlang.org/)\n- [RxJS](https://rxjs.dev/)\n- [RESTify](http://restify.com/)\n- [GraphQL](https://graphql.org/)\n- [Webpack Module Federation](https://webpack.js.org/concepts/module-federation/)\n- [HLS (HTTP Live Streaming)](https://developer.apple.com/streaming/)\n- [DASH (Dynamic Adaptive Streaming over HTTP)](https://github.com/Dash-Industry-Forum/dash.js)\n- [HTTP2 Overview](https://developers.google.com/web/fundamentals/performance/http2)\n- [Quick (HTTP/3)](https://en.wikipedia.org/wiki/QUIC)\n- [Lerna](https://lerna.js.org/)\n- [Hawkins Design System](https://design-system.sequoiacapital.com/)\n\n[‚¨ÜÔ∏è Back to Top](#table-of-contents)\n\n---\n\n# Video Overview\n\nThe video delves into the comprehensive system design of Netflix's frontend, exploring functional and non-functional requirements, the technical stack utilized at Netflix, and the detailed component-level architecture. It examines HTTP protocols, including HTTP2 and HTTP3, essential for streaming, and discusses techniques like configurable UI and micro frontends. The episode also briefly revisits backend elements essential for the frontend design. It culminates in a discussion on design principles and component breakdowns relevant to Netflix's robust system architecture.\n\n[‚¨ÜÔ∏è Back to Top](#table-of-contents)\n\n---\n\n# Detailed Technical Content\n\n## 3.1 Functional and Non-Functional Requirements\n\n- **Functional Requirements**: \n  - Focused on modules like:\n    - Movie/TV series catalog\n    - Profiles\n    - Subscriptions\n    - Reviews\n    - User interactions (e.g., login/signup, parental controls)\n    \n  - The supply-side functionality also highlights:\n    - Content uploading\n    - Video analytics\n    - Metadata configuration\n    - Tagging\n    - SEO optimization\n  \n- **Non-Functional Requirements**: \n  - Emphasizes cross-platform support, video streaming protocols, responsive UI, and more:\n    - Location-based serving\n    - Asset optimization\n    - Resource hinting\n    - Cascading open graph tags for SEO\n    - Deep linking\n    - Performance metrics (e.g., server-side rendering (SSR), client-side hydrating)\n    - Security concerns (e.g., data caching)\n\n> These requirements ensure robust video consumption across diverse devices and network conditions.\n\n[‚¨ÜÔ∏è Back to Top](#table-of-contents)\n\n---\n\n## 3.2 Scoping\n\n- **Scoping Limitations**: \n  - Given the extensive system design complexity, not everything can be covered in a single discussion. Therefore, key segments emphasized include:\n    - Multilingual support\n    - Catalog management\n    - Video playback features\n    - UI configurability\n  \n- **Focused Elements**: \n  - Critical elements for design included:\n    - Multi-user experiences (e.g., user profile management)\n    - Advanced video functionalities (e.g., speed control, quality management, subtitle support)\n\n[‚¨ÜÔ∏è Back to Top](#table-of-contents)\n\n---\n\n## 3.3 Tech Stack of Netflix\n\n- **Frontend Framework**: \n  - Standard use of **ReactJS** for building rich user interfaces, augmented with **TypeScript** for type safety, ensuring maintenance easeability.\n\n- **Reactive Programming**: \n  - **RxJS** for an observable pattern to handle asynchronous data streams and event-driven programming efficiently.\n\n- **API Layer**: \n  - Utilizes both **RESTify** and **GraphQL** for service orchestration and communication, preferring GraphQL for its single request model flexibility and neat schema management through a tool called **Falker**.\n\n- **Build Tools and Practices**: \n  - Adoption of **Webpack** with Module Federation for micro frontend architectures, promoting independent deployment of frontend modules.\n\n- **MonoRepo Management**: \n  - Use of **Lerna** allows multiple projects within a single repository, optimizing dependency management and",
  "createdAt": "2025-07-13T18:15:12.246Z",
  "updatedAt": "2025-07-14T01:55:10.092Z",
  "tags": [
    "react",
    "typescript",
    "graphql",
    "system-design",
    "frontend-system-design",
    "streaming-media",
    "progress-components",
    "file-storage",
    "code-editor"
  ]
}