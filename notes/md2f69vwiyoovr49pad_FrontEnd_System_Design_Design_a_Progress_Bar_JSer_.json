{
  "id": "md2f69vwiyoovr49pad",
  "topic": "FrontEnd System Design - Design a Progress Bar | JSer - JavaScript & Algorithm",
  "content": "**Filtered Resources:**\n\n* [Progress Bar API Design](https://developer.mozilla.org/en-US/docs/Web/API/HTMLProgressElement)\n* [JavaScript Timers and Delays](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout)\n* [CSS Transitions](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions)\n* [CSS Linear Gradient](https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient)\n* [Shadow DOM and Encapsulation](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM)\n\n---\n\n**Video Overview:**\n\nThe video focuses on implementing a **progress bar** for monitoring API calls using a systematic six-step system design approach. It delves into the perceived simplicity of the task, which requires thoughtful consideration to accurately reflect system design capabilities. The creator simulates the process of designing this functionality with detailed explanations of key technical decisions. Through the design of a progress bar that responds dynamically to API calls, the video highlights the nuances and complexities involved, such as dealing with asynchronous behavior, overlapping requests, and optimally managing state transitions.\n\n---\n\n**Detailed Technical Content:**\n\n### System Design Overview\n\n1. **Understanding the Problem:**\n   - Many web applications use progress bars for tasks like file uploads, downloads, or API monitoring.\n   - The goal here is to design a **progress bar that monitors API calls**, displaying progress during ongoing API requests.\n\n2. **Defining Scope:**\n   - Show progress bar only for long-running requests to avoid unnecessary user distraction.\n   - Implement logic to handle overlapping API requests and ensure correct progress rendering.\n   - Expose APIs to allow integration with other modules for improved modularity.\n\n3. **Analyzing Real Cases:**\n   - Determine common behaviors in API requests like starting, overlapping, and timing out.\n   - Establish rules for when the progress bar should appear and disappear, based on API activity.\n\n### High-Level System Design\n\n4. **Design Considerations:**\n   - Separate the UI components from logic to maintain clean architecture.\n   - Use CSS transitions for aesthetic progress bar movement.\n   - Manage state with structures to switch from idle, loading, to completed efficiently.\n\n5. **Low-Level System Design:**\n   - Implement a state machine with states , , and .\n   - Establish transitions based on API call events. For example, transitioning to  only after a predefined delay threshold to filter out short request blips.\n   - Use  for managing time delays in state transitions.\n\n6. **Failure Handling:**\n   - Ensure proper handling of API timeouts and unexpected delays by showing progression to a maximum of 95%, then maintaining a suspenseful hold until resolution.\n   - Implement event listeners to handle transition end events and appropriately scale the progress to completion.\n\n### Detailed Implementation\n\n1. **JavaScript Core Implementation:**\n   - Define a progress bar using a simple , styled with CSS for visual representation.\n   - Utilize JavaScript for state management:\n     \n   - Implement method to switch states based on API calls:\n     \n\n2. **CSS for Progress Bar:**\n   - Utilize linear gradients for the aesthetic fill of the progress bar.\n   - Implement CSS transitions to smoothly animate the progress:\n     \n\n3. **Managing State Transitions:**\n   - Use JS event listeners to manage transitions. Upon completion, reset the state to idle, ensuring no memory leak with timers.\n   - Logic encapsulation to prevent overlap and mismanagement of concurrent requests.\n\n4. **Optimization and Edge Cases:**\n   - Fine-tune animation durations and look ahead for overlaps.\n   - Consider improving the animation legibility and responsiveness based on user feedback.\n\n### Key Takeaways\n\n- **Separation of Concerns:** Clear distinction between UI management and business logic results in a clean, maintainable codebase.\n- **Handling Asynchronous Operations:** Proper handling of asynchronous nature of API calls, ensuring UI reflects actual state transitions correctly.\n- **State Management:** Utilization of state patterns simplifies operation flow, adapting quickly between operational contexts.\n- **User Experience Optimization:** Efficiently manage visual feedback through state-driven UI transitions, reducing user frustration.\n- **System Design Philosophy:** Emphasize a structured system design process results in better analytical outcomes and operational clarity.",
  "createdAt": "2025-07-14T01:23:19.820Z",
  "updatedAt": "2025-07-14T03:27:08.043Z",
  "keywords": [
    "javascript",
    "java",
    "progress-components",
    "frontend-system-design",
    "system-design",
    "file-storage",
    "streaming-media",
    "code-editor"
  ]
}