{
  "id": "md2f71c4s00w5qwagu",
  "topic": "Frontend System Design Questions ( Poll Widget ) - HLD, LLD, Interview Experience, etc ðŸ”¥ðŸ”¥",
  "content": "**1) Filtered Resources (technical links only):**\n\n- [Scrimba Frontend Developer Career Path](https://v2.scrimba.com/the-frontend-developer-career-path-c0j?via=roadsidecoder30&pricing)\n- [Frontend System Design Interview Series](https://www.youtube.com/playlist?list=PLKhlp2qtUcSaSnNnNffRPIU3DRQ2xAdj8)\n- [Source Code for Frontend System Design Questions](https://github.com/piyush-eon/frontend-interview-questions/tree/master/frontend-system-design-questions)\n- [Complete Data Structures and Algorithms with JS Course](https://www.youtube.com/playlist?list=PLKhlp2qtUcSZtJefDThsXcsAbRBCSTgW4)\n- [JS Interview Series](https://www.youtube.com/watch?v=oUWRxJ19gfE&list=PLKhlp2qtUcSaCVJEt4ogEFs6I41pNnMU5&index=1)\n- [React Beginner's Project Tutorials](https://www.youtube.com/playlist?list=PLKhlp2qtUcSa_rX7glmB7HyFsEOEQa0Uk)\n\n**2) Video Overview:**\n\nThis video discusses designing a scalable poll widget component for frontend system design interviews. The focus is on requirement gathering, high-level design (HLD), low-level design (LLD), API structure, optimizations, and accessibility considerations. Additionally, strategies for embedding the widget in different platforms and providing customization options are covered. The video aims to prepare viewers for common frontend system design questions encountered during interviews and also highlights related courses and tutorials for enhancing technical skills.\n\n**3) Detailed Technical Content:**\n\n**Problem Statement:**\n- The task is to design a scalable poll widget that includes functionalities like voting, viewing results, and customization.\n- Real-time update of poll results, single and multiple vote options, and accessibility features are essential components of the widget.\n\n**Requirement Gathering:**\n*Functional Requirements:*\n- **Voting System:** Users should be able to cast a vote or remove their vote. The results should display the number of votes and percentages in real-time.\n- **Multiple Votes:** The widget should support both single and multiple vote selections.\n- **Vote Persistence:** Votes should persist across sessions via local storage, which ensures seamless user experience after page reloads.\n- **Customizability:** Users should be able to customize the widget's appearance from outside, i.e., without altering internal component code.\n- **Accessibility Features:** Integration of ARIA tags and keyboard navigation to ensure usability for individuals with disabilities.\n\n*Non-Functional Requirements:*\n- **Performance Optimization:** Implement performance enhancements such as using  instead of  for animations.\n- **Responsiveness:** Ensure the poll widget is usable on various devices including desktops, tablets, and smartphones.\n- **Scalability:** The solution should facilitate easy scaling by allowing external configurations via props.\n- **Cross-browser Compatibility:** The widget should function consistently across major web browsers.\n\n**High-Level Design (HLD):**\n- The HLD involves conceptualizing the component's architecture without delving into technical specifics.\n- Key Elements:\n  - **Poll Widget:** Comprising a title/question, options for voting, a real-time results display, and functionality for changing/removing votes.\n  - **Vote Mechanism:** Configuration allowing either single or multiple selections.\n  - **Integration Layer:** Flexibility to encapsulate behavior such as on-vote and on-remove actions externally.\n\n**Low-Level Design (LLD):**\n- **Data Model:**\n  - Poll data should include an ID, title, total vote count, and an array of options.\n  - Options to include properties: ID, title, and vote count.\n- **Props Structure:**\n  - Define prop interfaces like  including poll ID, title, options array, and configurations for multiple voting.\n- **Styling Options:**\n  - Implement configurable styles for various components (e.g., container, options) to facilitate external customization.\n\n**API Structure:**\n- **Get Poll Data API:** Retrieves details of the specific poll using the endpoint .\n- **Vote API:** Submits user votes and requires payload containing poll ID and selected options. Endpoint .\n- **Remove Vote API:** Enables vote withdrawal with similar payload structure to the vote API, at endpoint .\n\n**Optimization Strategies:**\n- **Vote Persistence:** Use local storage to maintain session data.\n- **Performance Enhancements:** Prefer  over  for better animation performance.\n- **Loading Indicators:** Use skeleton loaders for improved user experience during data fetch operations.\n- **Scrollable Options:** Design enhancements to ensure overflow-friendly UI for multiple options.\n\n**Accessibility:**\n- **Semantic HTML Tags:** Employ elements like  and  to group form controls.\n- **ARIA Attributes:** Integrate ARIA labels to describe functionality for screen readers, enhancing usability.\n- **Keyboard Navigation:** Ensure all components can be navigated via keyboard, improving accessibility for users with disabilities.\n\n**Scalability and Embedding:**\n- Options include deploying via a CDN or npm package. The video suggests npm for React apps as a preferred approach.\n- Steps to make the component embeddable involve packaging as an npm module, enabling easy integration into existing projects.\n\n**4) Key Takeaways:**\n\n- Designing a poll widget for frontend interviews necessitates understanding both functional and non-functional requirements.\n- High-level design focuses on the architecture flow while low-level design details data handling, API interactions, and component structuring.\n- Implementing performance optimizations and accessibility features is crucial for crafting an effective and inclusive user component.\n- Real-world application insight into making components modular and embeddable demonstrates the software principle of reuse and scalability.\n- Preparing for frontend interviews involves understanding both the design and coding aspects, coupled with practical code implementation. These insights provide candidates with a robust framework to approach similar design problems effectively.",
  "createdAt": "2025-07-14T01:23:55.396Z",
  "updatedAt": "2025-07-14T01:23:55.396Z",
  "tags": [
    "react",
    "cdn",
    "system-design",
    "frontend-system-design",
    "streaming-media",
    "interview-prep",
    "chat-messaging",
    "file-storage",
    "code-editor",
    "progress-components"
  ]
}