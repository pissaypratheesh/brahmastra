{
  "id": "md2f7k4v9u0qv2znzui",
  "topic": "[Frontend System Design] - Notion",
  "content": "## Filtered Resources\n- Telegram: [Frontend Engineer Blog](https://t.me/frontend_engineer_blog)\n- Medium: [Evgenii Ray's Medium](https://evgeniiray.medium.com/)\n- LinkedIn: [Evgenii Ray's LinkedIn](https://www.linkedin.com/in/evgenii-ray/)\n- Diagram Link: [Drawio Diagram](https://viewer.diagrams.net/?tags=%7B%7D&highlight=0000ff&edit=_blank&layers=1&nav=1&title=New%20Notion.drawio#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D1b9UW7tGoVXWna_huOV6Toybnbr9t1aN_%26export%3Ddownload)\n\n## Video Overview\nThis video covers the intricate process of designing a Notion-like editor with a focus on both frontend and object-oriented design methods. It aims to create a highly extendable Markdown-like editor and explores different aspects like system design, lexer & parser architecture, database and API design, performance optimizations, and accessibility features. The tutorial provides a comprehensive breakdown of various architectural components and how they fit together to create a scalable and flexible text editor.\n\n## Detailed Technical Content\n\n### Introduction to Notion and System Design Plan\n- **Overview of Notion**: Notion is a web application that facilitates building custom workspaces using an advanced, self-developed Markdown syntax. Each page in Notion is akin to a Markdown page composed of multiple components such as text headings and database views.\n- **Design Plan**: The design plan consists of collecting general and advanced feature requirements, providing UI mockups, designing a customized Markdown parser, database design, and API design. The aim is to create a scalable structure that can easily incorporate new features and components.\n\n### General and Advanced Feature Requirements\n- **General Requirements**: Include creating a custom editor supporting live element transformation, building an extendable components library, supporting high page hierarchy, ensuring content accessibility, and maintaining efficient performance.\n- **Advanced Features**: Focus on the database feature for content grouping into custom views and offline operation support while maintaining efficient network communication.\n\n### Mock-Up and High-Level System Components\n- **UI Mock-Up**: Visually depicts how pages and components are structured in the application workspace.\n- **High-Level Architecture**: Emphasizes application router logic where users' journey begins. Each page's hierarchy is structured starting from a root page ID, enabling navigation and rendering of nested pages efficiently using a Single Page Application (SPA) architecture.\n\n### Lexer & Parser Architecture\n- **Purpose of Lexer and Parser**: A lexer tokenizes raw content for the parser to process, while the parser uses these tokens to generate HTML elements. The processing workflow involves converting text into parsable tokens using defined rules and rendering content based on processed tokens.\n- **Implementation**: Design a lexer interface with a method for processing lines of content using rules defined as regular expressions. A parser applies these tokens to render corresponding components through specified rendering functions.\n  \n### Notion Database Design\n- **Database Concept**: Unlike traditional relational databases, Notion's database functions as a page containing multiple child pages. Each page can be viewed in several arrangements such as timeline, calendar, or table views, depending on its metadata.\n- **Plugin-Based System**: New views are supported via plugin metadata allowing dynamic alignment with various presentation needs.\n\n### API Design\n- **GraphQL vs REST**: The application employs GraphQL for its flexibility and capability to handle various data fetching requirements efficiently, despite the slightly increased complexity in managing client-server state synchronization.\n- **Specific API Methods**: Covered three core methods:  for fetching page data,  for submitting changes, and subscriptions for handling live updates when multiple users edit a page concurrently.\n\n### Performance Optimization\n- **Network/JS Optimization**: Utilizes HTTP/2 for initiating page loads with server-pushed assets and service workers for offline caching. Bundling, code-splitting, and image optimization also serve to minimize resource load times.\n- **Rendering & CSS Optimization**: Leverages CSS animations and strategic class management to ensure smooth UI interactions and efficient DOM operations without unnecessary computations.\n\n### Accessibility Considerations\n- **Accessibility Plan**: Ensuring accessible use through responsive design by using REM units for scalability, offering hotkeys for faster navigation, and supporting various color schemes for user convenience. \n- **HTML Semantics**: Maintains semantic HTML to ensure screen readers and other assistive technologies can adequately interpret content. An emphasis is placed on satisfying WAI-ARIA guidelines where possible.\n\n## Key Takeaways\n- A comprehensive technical design requires careful planning of both back-end systems and front-end interfaces to ensure flexibility and scalability.\n- Employing a plugin-based architecture allows easy extensibility within the database view systems.\n- Lexers and parsers separate content processing logic into stages, optimizing performance and enabling feature extensibility.\n- GraphQL offers dynamic querying capabilities that can significantly ease the complexity of developing adaptable API interfaces for web applications.\n- Attention to optimization and accessibility ensures the application serves a broader audience efficiently and is future-proof against varying user expectations and environmental conditions.",
  "createdAt": "2025-07-14T01:24:19.759Z",
  "updatedAt": "2025-07-14T01:24:19.759Z",
  "tags": [
    "graphql",
    "http/2",
    "system-design",
    "frontend-system-design",
    "code-editor",
    "streaming-media",
    "social-media",
    "file-storage",
    "financial-systems"
  ]
}