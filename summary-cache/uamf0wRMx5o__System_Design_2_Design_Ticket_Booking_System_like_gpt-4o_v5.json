{
  "videoId": "uamf0wRMx5o",
  "title": "✅ System Design 2: Design Ticket Booking System like BookMyShow, District / HLD / LLD",
  "model": "gpt-4o",
  "summary": "## Filtered Resources\n\n- **System Design Resources**: \n  - [Design Diagram: High and Low-Level Design](https://interviewwithbunny.vercel.app/systemdesign/02)\n\n- **System Design Videos**:\n  - [System Design 1: Design Tiny URL](https://youtu.be/Y-BO_4XNw8c)\n  - [System Design 2: Design Ticket Booking System](https://youtu.be/uamf0wRMx5o)\n  - [System Design 3: E-Commerce Platform Architectures](https://youtu.be/Y-BO_4XNw8c)\n  - [System Design 4: OTT Platform Design](https://youtu.be/NH-f955mvGg)\n  - [System Design 5: Hotel Booking Application Design](https://youtu.be/mH2Ye3_vErw)\n  - [System Design 6: Food Delivery Application Design](https://youtu.be/rZyAgZuuZiA)\n  - [System Design 7: Proximity Search Design](https://youtu.be/6K6ihHNkO_0)\n  - [System Design 8: Chat Application Design](https://youtu.be/3HXFy_7M12E)\n  - [System Design 9: Distributed Job Scheduler Design](https://youtu.be/hLvB2haod5w)\n  - [System Design 10: Real-time Collaborative Text Editor](https://youtu.be/-eMtcFqj8vI)\n\n## Video Overview\n\nThis video explores the system design for a ticket booking application similar to BookMyShow or Ticketmaster. It discusses the intricacies of designing a scalable, highly available, and distributed ticket booking system. The tutorial addresses common challenges such as race conditions, seat locking mechanisms, and maintaining database consistency. We go through the functional and non-functional requirements, and both high-level and low-level design aspects, culminating in a detailed technical breakdown that highlights system scalability and performance considerations.\n\n## Detailed Technical Content\n\n### Understanding the Problem and Requirements Gathering\n\n**Functional Requirements:**\n- **Search Functionality**:\n  - Users should be able to search for events, shows, concerts, or movies by keywords, location, or date.\n  - The search function must be quick and responsive.\n\n- **View Event Details**:\n  - Once an event is selected, users should access full metadata—event information, performers, or movie details.\n\n- **Ticket Booking**:\n  - Critical to manage seat reservations.\n  - Handle ordering steps including selecting, securing, and paying for seats.\n\n**Non-Functional Requirements:**\n- **System Scaling**:\n  - The architecture should support high user volumes (100 million daily active users).\n  - Considerations for horizontal scalability using microservices.\n\n- **CAP Theorem**:\n  - Balance between consistency and availability.\n  - Availability prioritized for search and view functions.\n  - Consistency prioritized for booking to prevent double-booking scenarios.\n\n### Entity Creation\n\n**Core Entities**:\n- **User**: Represents the customer interacting with the system.\n- **Event**: Could be movies, concerts, or any bookable show.\n- **Venue**: Specific locations where events take place.\n- **Ticket**: Represents the booking and associated details.\n\n### API Design\n\n**API Endpoints**:\n- **Event Search API (GET)**:\n  - Search by title, location, and date.\n  - Returns a list with matching event IDs and potential metadata.\n  - Consider paginated responses for large result sets.\n\n- **Event Details API (GET)**:\n  - Provides full details of an event when selected.\n  - Returns metadata, location, and available seats.\n\n- **Booking API (POST)**:\n  - Manages reservation steps.\n  - Requires user authorization, seat information submitted in the request body.\n  - Reservation process should include a transaction ID for subsequent payment verification.\n\n- **Payment Confirmation API (POST)**:\n  - Finalizes booking upon successful payment.\n  - Receives booking ID for cross-referencing prior reservations made.\n\n### High-Level Design (HLD)\n\n**Overall Architecture**:\n- **Client Interface**: Web or mobile application interface for user interaction.\n- **API Gateway**: Routes requests, manages traffic, implements rate limiting.\n  \n**Microservices Design**:\n- **Booking Service**:\n  - Handles reservations, interacts with payment processing, and checks seating availability.\n  - Coordination with a Redis cache for transient data storage (e.g., temporary seat holds).\n\n- **Event Service**:\n  - Manages event metadata, interacts with a scalable NoSQL database (Cassandra) for storage.\n  - Interaction with Elasticsearch for faster read operations.\n\n- **Search Service**:\n  - Implements efficient search strategies, utilizing Elasticsearch to index and query large datasets.\n\n### Low-Level Design (LLD)\n\n**Database Design**:\n- **Relational DB (MySQL/PostgreSQL)**:\n  - Used for transactional data ensuring ACID properties.\n  - Manages seat reservation persistence and payment records.\n\n- **NoSQL DB (Cassandra)**:\n  - Scales horizontally, stores immutable metadata for fast reads and writes.\n  - Complemented by Elasticsearch for optimized search operations.\n\n**Data Flow**:\n- **Search Optimization**:\n  - Data from Cassandra ingested into Elasticsearch through periodic batch processes or CDC pipelines using technologies like Kafka and Debezium.\n\n- **Booking Flow**:\n  - Redis used to manage expirable locks on seat reservations.\n  - Seats held are transiently stored and purged upon transaction completion or timeout.\n\n### Key Takeaways\n\n- **Scalability**: Architected to support high traffic, intended to handle both peacetime and peak event surges efficiently.\n  \n- **Consistency and Availability**: Applied the CAP theorem to balance functionalities depending on their critical nature—ensured highly available search while maintaining consistency during booking.\n\n- **Data Management**: Leveraged a mix of databases to suit transactional versus analytical needs—Cassandra for event data and Elasticsearch for rapid query handling.\n\n- **System Reliability**: Instances like concurrent user booking management handled using Redis and cache eviction strategies, underpinning seat reservation integrity.\n\n- **Performance**: Designed microservices to isolate functional responsibilities, allowing seamless scaling based on workload distribution—efficient resource utilization while systematically managing inter-service dependencies.",
  "cachedAt": "2025-07-13T11:39:18.907Z",
  "generatedAt": 1752406758907
}