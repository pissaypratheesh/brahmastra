{
  "videoId": "4ijjIUeq6hE",
  "title": "Google Interview Question | System Design: Digital Wallet (3+ Approaches)",
  "keyword": "strong read consistency",
  "explanation": "## strong read consistency\n\nStrong read consistency ensures that any read operation on a database returns the most recent committed data, reflecting all previous writes. This means that once a transaction is committed, any subsequent read will see the updated state, preventing stale or inconsistent data from being presented to the user.\n\n### How it applies in this context:\nIn the context of the digital wallet system, strong read consistency is crucial for ensuring that users see accurate account balances and transaction statuses immediately after they are processed. This is particularly important in financial applications where users need to trust that their transaction information is up-to-date and reliable, especially when handling high volumes of transactions.\n\n### Diagram:\n```mermaid\ngraph TD\n    A[User Requests Balance] --> B[Transaction Service]\n    B --> C{Transaction Status}\n    C -->|Committed| D[Return Updated Balance]\n    C -->|Pending| E[Return Pending Status]\n    C -->|Failed| F[Return Error Message]\n    D --> G[User Sees Accurate Balance]\n    E --> G\n    F --> G\n```\n\n### Code Example in JavaScript\nHereâ€™s a simple example demonstrating strong read consistency in a digital wallet context using a mock function to simulate a transaction and balance retrieval:\n\n```javascript\nclass DigitalWallet {\n    constructor() {\n        this.balances = {};\n    }\n\n    // Simulate a transaction\n    async makeTransaction(userId, amount) {\n        // Check if user exists\n        if (!this.balances[userId]) {\n            this.balances[userId] = 0;\n        }\n\n        // Update balance\n        this.balances[userId] += amount;\n\n        // Simulate a delay to mimic database write\n        await new Promise(resolve => setTimeout(resolve, 100));\n        return this.balances[userId];\n    }\n\n    // Ensure strong read consistency\n    async getBalance(userId) {\n        // Simulate a delay to mimic database read\n        await new Promise(resolve => setTimeout(resolve, 100));\n        return this.balances[userId] || 0;\n    }\n}\n\n// Example usage\n(async () => {\n    const wallet = new DigitalWallet();\n    await wallet.makeTransaction('user1', 100); // User 1 deposits $100\n    const balance = await wallet.getBalance('user1'); // Strong read consistency ensures this returns 100\n    console.log(`User 1 balance: $${balance}`); // Output: User 1 balance: $100\n})();\n```\n\nIn this example, the `makeTransaction` method updates the user's balance, and the `getBalance` method ensures that the most recent balance is returned, demonstrating strong read consistency in action.",
  "model": "gpt-4o-mini",
  "generatedAt": "2025-07-13T16:50:25.287Z",
  "lastEditedAt": "2025-07-13T16:51:37.893Z"
}